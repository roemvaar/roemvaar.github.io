---
layout: post
title: "Building OSo (RTOS) Part 1: Introduction"
date: 2024-11-15 00:32:13
description: Introduction to OSo and RTOS fundamentals. This is the first post about my journey creating a Real-Time Operating System from scratch.
tags: rtos
categories: OSo
tabs: true
---

```html
I'm building my own RTOS, take a look at the GitHub repo: https://github.com/roemvaar/oso
```

During my time working at John Deere, I started working on an Embedded Linux project with little
background in operating systems (OS).

I was always curious as to what was in the inner parts of an
OS, hence I read *Operating Systems: Three Easy Pieces* (OSTEP) by Remzi and Andrea
Arpaci-Dusseau and all the pieces began to come together, or at least that's what I thought. I
went and get my hands dirty with the Linux kernel by inspecting the source code but I still wasn't
grabbing all of it, so I decided to code my own Operating Systems.

## Why am I building yet another Operating System?

I enrolled in the CS 652 Real-Time Programming (trains) class offered at school, where
the main goal is to design and implement a real-time operating system. I had to 
unenroll from the class for personal reasons, but the seed had been planted in me.

In October 2024, I started working in my free time on my operating system, OSo, which means bearing in
Spanish. At this point, I have good progress and in this blog post, I will give a brief introduction
to the high-level architecture of my system its capabilities, and provide a couple of working
examples.

## OSo Goals

The main goal of this project is to create a small operating system for "real-world" embedded
systems.

I started from scratch to get a better understanding of things that I might take for granted,
such as booting, device interaction, memory management, timing, threading and concurrency.

## OSo Design

Initially, it will be targeted at the Raspberry Pi 4b+, which is an accessible development
board.

I decided to use C as the programming language for OSo because I have good knowledge of the
language. I wanted to use Rust to learn a new programming language but ended up with C because
implementing an OS from scratch is a hard challenge in itself, I didn't want to shoot myself
in the foot by also having to learn a new language.

## Closing Thoughts

It goes without saying in tech, but quoting one of the greatest scientists ever, "we stand on the
shoulders of giants," and this occasion is no exception. I tried my best to do the design and
code myself for a better understanding of core concepts, but a lot of my work wouldn't have been
possible without the guidance of different materials of smart people who worked on this task before
me such as the [CS 652 material](https://student.cs.uwaterloo.ca/~cs452/F23/), [rpi4-osdev](https://www.rpi4os.com/)
by Adam Greenwood-Byrne, and [raspberry-pi-os](https://s-matyukevich.github.io/raspberry-pi-os/docs/lesson01/rpi-os.html) by Sergey Matyukevich.

I plan to write a series of blog posts relating to my work on this project. I don't want
to make this a step-by-step tutorial on how to create your own OS, there are plenty of resources out
there to do that (I recommend starting by looking at the raspberry-pi-os that I pointed out previously),
instead, my main goal is to improve my technical writing abilities and use these blog posts to
present the design and development of my work in a structured fashion, along with the challenges,
and how I overcame them.
